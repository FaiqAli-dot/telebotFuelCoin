#include "stdlib.fc";

;; Define balance function
int balance() impure inline asm "BALANCE";

;; Constants
const int OP_SPLIT_TON = 0x123;       ;; Operation code for splitting TON
const int OP_CHANGE_ADDRESSES = 0x456; ;; Operation code for changing addresses
const int OP_WITHDRAW_FUNDS = 0x789;   ;; Operation code for withdrawing funds

const int MIN_TON_FOR_STORAGE = 30000000; ;; 0.03 TON
const int MIN_TON_FOR_SPLIT = 5000000;    ;; 0.005 TON
const int MIN_TON_FOR_FEES = 5000000;     ;; 0.005 TON reserved for fees

const int ERR_INSUFFICIENT_FUNDS = 100;
const int ERR_SPLIT_TOO_SMALL = 101;
const int ERR_NOT_OWNER = 703;
const int ERR_INVALID_OP = 0xffff;

;; Improved slice comparison function
int slice_equal?(slice a, slice b) inline {
    return (slice_bits(a) == slice_bits(b)) & (slice_refs(a) == slice_refs(b)) & (slice_hash(a) == slice_hash(b));
}

;; Storage structure optimization
;; owner_address: MsgAddress
;; address1: MsgAddress
;; address2: MsgAddress
;; address3: MsgAddress
() save_data(slice owner_address, slice addr1, slice addr2, slice addr3) impure inline {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_ref(
            begin_cell()
                .store_slice(addr1)
                .store_slice(addr2)
                .store_slice(addr3)
                .end_cell()
        )
        .end_cell());
}

(slice, slice, slice, slice) load_data() inline {
    slice ds = get_data().begin_parse();
    slice owner_address = ds~load_msg_addr();
    slice ref_slice = ds~load_ref().begin_parse();
    return (owner_address, ref_slice~load_msg_addr(), ref_slice~load_msg_addr(), ref_slice~load_msg_addr());
}

;; Improved message sending with bounce
() send_tons(slice address, int amount, int mode) impure inline {
    var msg = begin_cell()
        .store_uint(0x18, 6)  ;; Add bounce flag for better error handling
        .store_slice(address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
    send_raw_message(msg.end_cell(), mode);
}

;; Safe fund return function
() return_funds(slice sender_address, int amount) impure inline {
    if (amount > MIN_TON_FOR_FEES) {
        send_tons(sender_address, amount - MIN_TON_FOR_FEES, 1);
    }
}

;; Calculate required fees
int calculate_required_amount(int split_count) inline {
    return MIN_TON_FOR_STORAGE + (MIN_TON_FOR_FEES * split_count) + (MIN_TON_FOR_SPLIT * split_count);
}

;; Improved process_simple_transfer with better fund management
() process_simple_transfer(slice sender_address, int msg_value) impure {
    ;; Calculate total required amount for the operation
    int required_amount = calculate_required_amount(4);
    
    ;; Check if we have enough funds
    if (msg_value < required_amount) {
        return_funds(sender_address, msg_value);
        return ();
    }

    ;; Calculate available amount for splitting
    int total_fees = MIN_TON_FOR_STORAGE + (MIN_TON_FOR_FEES * 4);
    int available_amount = msg_value - total_fees;
    int split_amount = available_amount / 4;

    ;; Load addresses
    (slice owner_address, slice addr1, slice addr2, slice addr3) = load_data();

    ;; Validate owner address
    if (slice_bits(owner_address) == 0) {
        return_funds(sender_address, msg_value);
        return ();
    }

    ;; Send funds with proper mode flags
    ;; Mode 1: Pay fees separately
    ;; Mode 2: Pay fees from balance
    send_tons(addr1, split_amount, 1);
    send_tons(addr2, split_amount, 1);
    send_tons(addr3, split_amount, 1);
    send_tons(owner_address, split_amount, 1);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Parse incoming message
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    ;; Ignore all bounced messages
    if (flags & 1) {
        return ();
    }

    ;; Check minimum required value
    if (msg_value < MIN_TON_FOR_STORAGE + MIN_TON_FOR_FEES) {
        return_funds(sender_address, msg_value);
        return ();
    }

    ;; Handle empty message body as simple transfer
    if (in_msg_body.slice_empty?() ) {
        process_simple_transfer(sender_address, msg_value);
        return ();
    }
    if (in_msg_body.slice_bits() < 32){
        process_simple_transfer(sender_address, msg_value);
        return ();
    }

    ;; Parse operation
    int op = in_msg_body~load_uint(32);
    (slice owner_address, slice addr1, slice addr2, slice addr3) = load_data();

    ;; Handle different operations
    if (op == OP_CHANGE_ADDRESSES) {
        ;; Only owner can change addresses
        if (slice_equal?(sender_address, owner_address) == 0) {
            return_funds(sender_address, msg_value);
            return ();
        }

        ;; Ensure enough bits for addresses
        if (in_msg_body.slice_bits() < 267 * 4) {
            return_funds(sender_address, msg_value);
            return ();
        }

        ;; Update addresses
        save_data(
            in_msg_body~load_msg_addr(), ;; new owner
            in_msg_body~load_msg_addr(), ;; new addr1
            in_msg_body~load_msg_addr(), ;; new addr2
            in_msg_body~load_msg_addr()  ;; new addr3
        );

        return_funds(sender_address, msg_value);
        return ();
    }

    if (op == OP_WITHDRAW_FUNDS) {
        ;; Only owner can withdraw
        if (slice_equal?(sender_address, owner_address) == 0) {
            return_funds(sender_address, msg_value);
            return ();
        }

        ;; Load destination address
        if (in_msg_body.slice_bits() < 267) {
            return_funds(sender_address, msg_value);
            return ();
        }
        
        slice dest_address = in_msg_body~load_msg_addr();
        
        ;; Calculate safe withdrawal amount
        int contract_balance = balance();
        int safe_withdraw_amount = contract_balance - MIN_TON_FOR_STORAGE - MIN_TON_FOR_FEES;

        if (safe_withdraw_amount > 0) {
            send_tons(dest_address, safe_withdraw_amount, 1);
        }
        
        return ();
    }

    ;; Default to simple transfer for unknown operations
    process_simple_transfer(sender_address, msg_value);
}

;; Get method to retrieve current addresses
(slice, slice, slice, slice) get_info() method_id {
    return load_data();
}